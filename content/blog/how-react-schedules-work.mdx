---
title: "How state update works internally"
description: "I'm looking for a job"
date: "2026-01-26"
topic: "React"
draft: true
---


I'm sure most of the react developers have gone through this once, updating the state and trying to `console.log` it in the next 
line and wondering for a hour why my state isn't changing. 


Let's start with a few examples and we will dig deeper
<Sandpack
template="react"
showConsole={true}
files={{
"/App.js": `import { useState } from "react";
import "./styles.css";

export default function App() {
  const [count, setCount] = useState(0);
  const [stale, setStale] = useState(0);
  const [updated, setUpdated] = useState(0);

  const handleLogAfterSet = () => {
    setCount(count + 1);
    console.log(\`After setCount: \${count}\`);
  };

  const handleSetThreeTimes = () => {
    setStale(stale + 1);
    setStale(stale + 1);
    setStale(stale + 1);
  };

  const handleSetWithUpdater = () => {
    setUpdated(prev => prev + 1);
    setUpdated(prev => prev + 1);
    setUpdated(prev => prev + 1);
  };

  return (
    <div className="container">
      <div className="card">
        <span className="label">console.log after setState</span>
        <span className="count">{count}</span>
        <button className="btn" onClick={handleLogAfterSet}>increment</button>
      </div>
      <div className="card">
        <span className="label">setState(val + 1) x3</span>
        <span className="count">{stale}</span>
        <button className="btn" onClick={handleSetThreeTimes}>increment x3</button>
      </div>
      <div className="card">
        <span className="label">setState(prev =&gt; prev + 1) x3</span>
        <span className="count">{updated}</span>
        <button className="btn" onClick={handleSetWithUpdater}>increment x3</button>
      </div>
    </div>
  );
}`,
"/styles.css": `.container {
  display: flex;
  align-items: stretch;
  justify-content: center;
  padding: 32px 16px;
  gap: 16px;
}

.card {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
  padding: 20px 16px;
  border: 1px solid #e2e2e2;
  border-radius: 10px;
  min-width: 140px;
}

.label {
  font-size: 0.75rem;
  font-family: monospace;
  color: #666;
  text-align: center;
}

.count {
  font-size: 2.5rem;
  font-weight: 700;
  font-family: monospace;
  color: #1a1a2e;
}

.btn {
  padding: 8px 20px;
  font-size: 0.85rem;
  font-weight: 500;
  color: #fff;
  background: #1a1a2e;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: background 0.2s;
}

.btn:hover {
  background: #16213e;
}

.btn:active {
  transform: scale(0.97);
}
`
}}
/>
```jsx 
  const handleLogAfterSet = () => {
    setCount(count + 1);
    console.log(\`After setCount: \${count}\`);
  };
```

Try clicking the first `increment` button and check the console tab, you will see still see `0` as a value instead of 
`1` _Hmm, that seems odd isn't it?_

```jsx
  const handleSetThreeTimes = () => {
    setState(stale + 1);
    setState(stale + 1);
    setState(stale + 1);
  };
```
Click the second `increment` button, you would except it to increment 3 times but it only increment once, 
_Hmm, that seems odd again_

```jsx 
 const handleSetWithUpdater = () => {
    setUpdated(prev => prev + 1);
    setUpdated(prev => prev + 1);
    setUpdated(prev => prev + 1);
  };

```

now click the 3rd `increment` button well now it does increment three times, _what is going on here?_

React is easy to get started with but also soon we crash into a weird issues like these that makes us wonder 
_what the hell is even going on_ and it's often time what we think of how it works vs how it is actually working.

if you already have answer to these all than we will dig deeper into how it's working internally, 
but if you don't know it's fine we will understand this anyway.

<IntendedAudience>
This blog is for developers who already know React basics and want to understand how React works internally. You should be comfortable with JavaScript concepts like the call stack, event loop and task queues.
</IntendedAudience>

# Recursive Rendering

React 16 introduced the new reconciliation algorithm, old reconciliation algorithm used to render everything 
recursivly meaning once the rendering process starts there is no way for us to stop it unless it finish the work,
itself now that lead some issues.

<img src="/blog/scheduler/angry.svg" alt="React UI Runtime" width="400" height="100" style={{ display: 'block', margin: '2rem auto' }} />

say your browser is working on `60fps`, which is 60 frames per seconds, 1 frame in `16.6ms`. your browser 
has to render `1` frame in `16ms`. during this one rendering process it needs to reflow, repaint etc
if your javascript itself takes more than `16ms` or `16ms` it is not giving time for browser to do the work it would drop the 
frame what would lead to janky UI.

I have already written a blog you can check that out, [understanding why react fiber exists](https://inside-react.vercel.app/blog/understanding-why-react-fiber-exists)



# New Reconciliation algorithm

<img src="/blog/scheduler/zoro.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

so with this new reconciliation algorithm react breaks 
the rendering process into a small unit of work, rather doing all rendering process once we perform a rendering 
in a small unit of work in a time slice

<img src="/blog/scheduler/wait.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

It's a simple concept, our rendering is divided into a small unit of work instead of doing everything at once 
we do a small chunk of works in a time slice(~5ms) and let the browser do it's work as well.

so here the `5ms` is not a hard rule but some heuristic value, your browser needs to repaint and go through its own process 
so for the safer side to prevent a frame drop and janky UI it takes the frame interval of `5ms`

# State update is not synchronous
```jsx 
  const handleClick = () => {
    const isHuman = true
    if(isHuman){
      console.log("Hello Human üëã");
    }else{
      console.log("üò≤üò≤");
    }
    setCount(count + 1);
    console.log(count)
  }
  <button onClick={handleClick}>click me</button>

```

<LineExecutionDemo
  title="handleClick() Execution"
  speed={600}
  lang="jsx"
  startAt={0}
  stopAt={7}
  console={[
    { line: 3, text: 'Hello Human üëã' },
  ]}
  code={`const handleClick = () => {
  const isHuman = true
  if(isHuman){
    console.log("Hello Human üëã");
  }else{
    console.log("üò≤üò≤");
  }
  setCount(count + 1); // ‚è≥ schedules update
  console.log(count)   // still 0!
}`}
/>

When you click a button function execution starts, it begins to run synchronously, the moment 
you come to 

```jsx 
setCount(prev+1)
```
it doesn't immediately start the rendering process rather 


react creates an update object first enqueue that updateObject, it will now go all the way up to the 
root fiber and mark everything as a needing update (childrenLane)

still the rendering hasn't started yet

## State update is not sync

    The set function only updates the state variable for the next render. If you read the state variable after calling the set function, you will still get the old value that was on the screen before your call.

This is easy to understand, we've already seen how setState() schedules re-render in next tick, it is not sync and the updated value can only be got from next render since the state update is done in useState() not in setState().


## setState() with same value might still trigger re-render

    If the new value you provide is identical to the current state, as determined by an Object.is comparison, React will skip re-rendering the component and its children. This is an optimization. Although in some cases React may still need to call your component before skipping the children, it shouldn‚Äôt affect your code.


Early bailout ‚Üí if React can determine before starting the render that nothing changed, it skips creating work for this fiber and all children.

Normal bailout (not early) ‚Üí React already started the render for this fiber. At this point, it compares previous memoized state with new state. If identical ‚Üí skips children, but the fiber itself was ‚Äútouched‚Äù for this render.


# requestIdleCallback




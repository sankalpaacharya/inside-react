---
title: "How state update works internally"
description: "I'm looking for a job"
date: "2026-01-26"
topic: "React"
draft: true
---


I'm sure most of the react developers have gone through this once, updating the state and trying to `console.log` it in the next 
line and wondering for a hour why my state isn't changing. 


Let's start with a few examples and we will dig deeper
<Sandpack
template="react"
showConsole={true}
files={{
"/App.js": `import { useState } from "react";
import "./styles.css";

export default function App() {
  const [count, setCount] = useState(0);
  const [stale, setStale] = useState(0);
  const [updated, setUpdated] = useState(0);

  const handleLogAfterSet = () => {
    setCount(count + 1);
    console.log(\`After setCount: \${count}\`);
  };

  const handleSetThreeTimes = () => {
    setStale(stale + 1);
    setStale(stale + 1);
    setStale(stale + 1);
  };

  const handleSetWithUpdater = () => {
    setUpdated(prev => prev + 1);
    setUpdated(prev => prev + 1);
    setUpdated(prev => prev + 1);
  };

  return (
    <div className="container">
      <div className="card">
        <span className="label">console.log after setState</span>
        <span className="count">{count}</span>
        <button className="btn" onClick={handleLogAfterSet}>increment</button>
      </div>
      <div className="card">
        <span className="label">setState(val + 1) x3</span>
        <span className="count">{stale}</span>
        <button className="btn" onClick={handleSetThreeTimes}>increment x3</button>
      </div>
      <div className="card">
        <span className="label">setState(prev =&gt; prev + 1) x3</span>
        <span className="count">{updated}</span>
        <button className="btn" onClick={handleSetWithUpdater}>increment x3</button>
      </div>
    </div>
  );
}`,
"/styles.css": `.container {
  display: flex;
  align-items: stretch;
  justify-content: center;
  padding: 32px 16px;
  gap: 16px;
}

.card {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
  padding: 20px 16px;
  border: 1px solid #e2e2e2;
  border-radius: 10px;
  min-width: 140px;
}

.label {
  font-size: 0.75rem;
  font-family: monospace;
  color: #666;
  text-align: center;
}

.count {
  font-size: 2.5rem;
  font-weight: 700;
  font-family: monospace;
  color: #1a1a2e;
}

.btn {
  padding: 8px 20px;
  font-size: 0.85rem;
  font-weight: 500;
  color: #fff;
  background: #1a1a2e;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: background 0.2s;
}

.btn:hover {
  background: #16213e;
}

.btn:active {
  transform: scale(0.97);
}
`
}}
/>
```jsx 
  const handleLogAfterSet = () => {
    setCount(count + 1);
    console.log(\`After setCount: \${count}\`);
  };
```

Try clicking the first `increment` button and check the console tab, you will see still see `0` as a value instead of 
`1` _Hmm, that seems odd isn't it?_

```jsx
  const handleSetThreeTimes = () => {
    setState(stale + 1);
    setState(stale + 1);
    setState(stale + 1);
  };
```
Click the second `increment` button, you would except it to increment 3 times but it only increment once, 
_Hmm, that seems odd again_

```jsx 
 const handleSetWithUpdater = () => {
    setUpdated(prev => prev + 1);
    setUpdated(prev => prev + 1);
    setUpdated(prev => prev + 1);
  };

```

now click the 3rd `increment` button well now it does increment three times, _what is going on here?_

React is easy to get started with but also soon we crash into a weird issues like these that makes us wonder 
_what the hell is even going on_ and it's often time what we think of how it works vs how it is actually working.

if you already have answer to these all than we will dig deeper into how it's working internally, 
but if you don't know it's fine we will understand this anyway.

<IntendedAudience>
This blog is for developers who already know React basics and want to understand how React works internally. 
You should be comfortable with JavaScript concepts like the call stack, event loop and task queues and 
some basics of react fiber and new reconciliation algorithm.
</IntendedAudience>

# Fiber Node 

React reads your jsx components and creates this in-memory UI tree called `Fiber`. This fiber 
tree is made of different `FiberNode`


```tsx
function FiberNode(
  this: $FlowFixMe,
  tag: WorkTag,        
  pendingProps: mixed, 
  key: ReactKey,       
  mode: TypeOfMode,    
) {
  ...
  // Tree structure
  this.return = null;   // Parent fiber
  this.child = null;    // First child fiber
  this.sibling = null;  // Next sibling fiber
  ...
  // State
  this.memoizedState = null; // (hooks for function components)
  ...
}
```

<img src="/blog/fiber/fiber.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />
Each fiber represents one piece of your UI. A component. A div. A button. Whatever. See those three properties in `FiberNode`? child, sibling, return. These are pointers. They connect fibers to other fibers, forming like a linked list.

And here's why this matters: React owns this data structure. It's just an object sitting in memory. React can walk it however it wants, stop whenever it wants, and resume whenever it wants.

I have another blog if you want to read, [understanding why react fiber exists](https://inside-react.vercel.app/blog/understanding-why-react-fiber-exists)

- [FiberNode](https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiber.js#L138-L211)

# memoizedState

memoizedState is the property in the `FiberNode` which hold all information about your hooks.

say you have a simple `App` component 

```tsx 
function App(){
  const [count, setCount] = useState(0);
  const [greet, setGreet] = useState("hello");

  const ref = useRef();
  return <>...</>
}
```
Now this your App component has a `FiberNode` internally and inside the `memoizedState` all your hooks 
information is stored as a linkedinlist.

<img src="/blog/scheduler/hook.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

we only had 2 hooks in our App component that's the reason you see `next: null` on the last hook
<details>
  <summary>`queue`</summary>
   <img src="/blog/scheduler/queue.png" alt="React UI Runtime" width="400" height="100"/> 
</details>

> These are some prior knowledge I wanted to discuss before we actually dig in.

# State update is not synchronous

I hope you are ready to dive into react internals now, let's start with an example

```jsx 
  const handleClick = () => {
    const isHuman = true
    if(isHuman){
      console.log("Hello Human üëã");
    }else{
      console.log("üò≤üò≤");
    }
    setCount(count + 1);
    console.log(count)
  }
  <button onClick={handleClick}>click me</button>

```

<LineExecutionDemo
  title="handleClick()"
  speed={600}
  lang="jsx"
  startAt={0}
  stopAt={7}
  skip={[4, 5]}
  console={[
    { line: 3, text: 'Hello Human üëã' },
    { line: 8, text: '0', type: 'log' },
  ]}
  code={`const handleClick = () => {
  const isHuman = true
  if(isHuman){
    console.log("Hello Human üëã");
  }else{
    console.log("üò≤üò≤");
  }
  setCount(count + 1); // ‚è≥ schedules update
  console.log(count)  
}`}
/>

When you click a button `handleClick` execution starts, it begins to run synchronously, the moment 
you come

```jsx 
setCount(prev+1)
```
it doesn't immediately start the rendering process, it first schedules an update and for that it calls 
`dispatchSetState` internally


# dispatchSetState

react creates an update object first enqueue that updateObject, it will now go all the way up to the 
root fiber and mark everything as a needing update (childrenLane)

still the rendering hasn't started yet

## State update is not sync

    The set function only updates the state variable for the next render. If you read the state variable after calling the set function, you will still get the old value that was on the screen before your call.

This is easy to understand, we've already seen how setState() schedules re-render in next tick, it is not sync and the updated value can only be got from next render since the state update is done in useState() not in setState().


## setState() with same value might still trigger re-render

    If the new value you provide is identical to the current state, as determined by an Object.is comparison, React will skip re-rendering the component and its children. This is an optimization. Although in some cases React may still need to call your component before skipping the children, it shouldn‚Äôt affect your code.


Early bailout ‚Üí if React can determine before starting the render that nothing changed, it skips creating work for this fiber and all children.

Normal bailout (not early) ‚Üí React already started the render for this fiber. At this point, it compares previous memoized state with new state. If identical ‚Üí skips children, but the fiber itself was ‚Äútouched‚Äù for this render.


# requestIdleCallback




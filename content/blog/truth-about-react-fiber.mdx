---
title: "React Fiber"
description: "React fiber"
date: "2026-01-26"
topic: "React"
draft: true
---

A while ago, scrolling Twitter, I stumbled upon this interesting post.


<div className='not-prose flex justify-center'> 
<TweetCard 
  id="1997359890021634509" 
  comments={47}
  reposts={177}
  likes={1400}
  bookmarks={999}
/>

</div>

This is a really good post. It sums up so much about React, in the post he mentions this which really had me thinking and it caught my interest to understand more about React

> react finally got freedom from the JS callstack. instead of recursive rendering, it‚Äôs this iterative stepping through fibers one by one. and that suddenly means react can pause. like just literally stop mid render, drop everything, let the browser repaint, handle input, chill, take a breath, then pick up exactly where it left off inside that huge UI tree. no more ‚Äúoh no i‚Äôm stuck deep in recursion‚Äù. you can‚Äôt get stuck because react isn‚Äôt using the builtin stack anymore. it‚Äôs rolling its own.

"react finally got freedom from the JS callstack" ü§î 

this is interesting because what problem would the JS callstack even have so that react had to get rid of it? many people 
will say fiber exist because js is a single thread programming language but it's not an entirely true, 

I see many windy discussion on internet when people talk about react fiber not being not very optimal way and just to optimize 
the rendering process reconciliation algorithm didn't need a re-write, every library comes with their own trade off and
they have their own way of solving problems

To understand the solution, we have to know the problem: what was hindering React's performance, what the React team came up with. This post explains 
about the React scheduler

# Story of Single thread

We know JavaScript is a single-threaded programming language, and for each execution context it only has one thread and a call stack that processes
the code line by line. It starts processing from the top to bottom. 


```js 

function doSomethingHeavy() {
  for (let i = 0; i < 1_000_000_000; i++) {} // blocks the thread
  
  console.log("Finished heavy task");
}

doSomethingHeavy();

do_imporatant_task(); // important task
```

From the above example, once we start the `doSomethingHeavy` task it will run until it finishes, but let's say 
we have an important task below, our important task is only executed once the `doSomethingHeavy` loop is finished. 

This is a simple synchronous program. JavaScript does support async programming as well, you have probably used `async` `await` in 
JavaScript. This is done by the [event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Execution_model).

You might suggest we can swap the position of the `doSomethingHeavy()` and `do_imporatant_task()` if we want `do_imporatant_task` to be executed 
first, but right now we know what the important task is. You wrote that function, we know what to place where, but what if it was undeterministic?

When you are running in the middle of a heavy task, a really important task pops up. You can't stop the running program in the middle and process something; 
you can't empty the call stack suddenly and start working on something else.

Let's see an example:

<Sandpack
template="react"
files={{
"/App.js": `import { useState } from "react";

export default function BlockingDemo() {
  const [count, setCount] = useState(0);
  const [isBlocked, setIsBlocked] = useState(false);

  const blockThread = () => {
    setIsBlocked(true);
    
    setTimeout(() => {
      const start = Date.now();
      let dummy = 0;
      
      // Block for 3 seconds
      while (Date.now() - start < 3000) {
        dummy += Math.random();
      }
      
      setIsBlocked(false);
    }, 0);
  };

  return (
    <div className="container">
      <div className="count">{count}</div>
      <div className="buttons">
        <button onClick={blockThread}>
          {isBlocked ? "Processing.." : "Start Work"}
        </button>
        <button onClick={() => setCount(count + 1)}>
          Click +1
        </button>
      </div>
    </div>
  );
}`,
"/styles.css": `.container {
  padding: 30px;
  max-width: 350px;
  margin: 0 auto;
}

.count {
  font-size: 3rem;
  font-weight: 600;
  text-align: center;
  margin-bottom: 20px;
  font-family: monospace;
}

.buttons {
  display: flex;
  gap: 10px;
}

button {
  flex: 1;
  padding: 12px;
  border: 1px solid #ccc;
  background: white;
  cursor: pointer;
  font-size: 0.9rem;
}

button:hover {
  background: #f5f5f5;
}
`,
"/sandbox.config.json": `{
  "infiniteLoopProtection": false
}`
}}
/>

Try clicking the `click +1` after you press `start work`. `start work` takes 3 seconds to finish. In that time, even if you press 
the `click +1` button, the count doesn't increment instantly, you have to wait for 3 seconds. This feels laggy and is a 
bad user experience.


# React 15

React 15 reconciler walked the component tree using recursive function calls. Once it started, it couldn't stop

```jsx
function updateComponent(component) {
  const children = component.render();
  
  children.forEach(child => {
    updateComponent(child); // ‚Üê Recursion
  });
}
```

Every call to `updateComponent` pushes a new frame onto JavaScript's call stack. For a tree with 1,000 components, 
that's 1,000 stack frames, all nested inside each other.

<React15InputDemo />

Imagine there is an input box and whatever the user types in that input box will be reflected on screen. The 
user typed the first character `s`, React will start the rendering process, calling `updateComponent` inside `updateComponent`

doing recursive calls, your call stack is filled with function calls now. While halfway through, the user typed another 
letter `a`, but now you can't stop. It can't say _hold on, the user typed again, let me restart with the new input_ 

JavaScript has no mechanism to pause a call stack, save its state, and resume later. React has to finish processing `s` before it can even see that you 
typed `a`. Each keystroke triggers another full reconciliation. Each time, React is trapped in recursion while your inputs pile up.


This is why React apps felt laggy.

## Priority

There was a second problem. React treated all updates equally. A button click got the same priority as a background data fetch. 
An animation got the same priority as logging. 

But some updates are urgent (user typing, clicking) and some can wait (analytics, prefetching). React had no way to express 
this because once reconciliation started, it ran to completion. Everything was equally important because everything blocked 
everything else.

Let's say you fetch some data from the server, a list of 500 products. The response comes back, 
and React starts rendering those 500 items to the screen. Halfway through, maybe 250 products rendered, you type a letter 
in the search box.

What should React do?

Stop rendering those products. Handle the keystroke first. Update the input box immediately. That's what 
the user cares about, seeing their typing reflected instantly.

The products can wait. A 100ms delay in showing search results? Barely noticeable. But a 100ms delay in seeing your keystroke? 
That feels broken.



# What we need?

<img src="/blog/fiber/need.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

Before we start looking for a solution we should be clear what we are looking in a solution? 

We are facing two main problem with this recursive reconciliation approach, 
- we can't pause the rendering process in middle (callstack level)
- we can't assume every update have same priority 

so, our solution should be able to pause the rendering process if there is another high priority task, pick that up 
render it first and continue working where it let off.

<img src="/blog/fiber/slow.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

_why pause at callstack level?_

because thats how browsers work, unless your callstack is empty event loop will not push the click, keystroke events 
from macro queue to a callstack


# Solution

The React team eventually realized that the problem wasn't just the reconciliation algorithm itself, but how it was being executed.

No amount of small optimizations could fix this, because recursion 
in JavaScript is fundamentally non-interruptible.

Instead of trying to bend the JavaScript call stack into doing 
something it was never meant to do, React gave up on the recursive 
model entirely. They stopped letting the JS engine drive 
reconciliation and built their own abstraction on top of it.

That abstraction is Fiber.

Fiber doesn't control the callstack, nothing can, because the 
callstack is fundamentally built into JavaScript itself. What 
Fiber controls is how we structure and execute our rendering work.

Instead of running the whole render process at once recursively, 
React now divides the entire reconciliation into small units of 
work. Now you only fill the callstack with a few small units of 
work for a short time (~5ms). After that, your callstack is empty, 
and the browser gets a chance to handle events like clicks or 
keystrokes.


To understand this better, let's look at the original design principles documented by Sebastian Markb√•ge (one of the core React team members):

<div className='not-prose flex justify-center my-6'> 
<GitHubIssueCard 
  owner="facebook" 
  repo="react" 
  issueNumber={7942}
  excerpt="I just wanted to document a few unique design patterns that apply to Fiber. Nothing in Fiber uses the normal JS stack. Meaning it does use the stack but it can be compiled into a flat function if needed. If I can't use recursion, how do I traverse through the tree? Learn to use the singly linked list tree traversal algorithm..."
  maxBodyLength={320}
/>
</div>



---
title: "Running React on different platform"
description: "The correct mental model for understanding React across platforms"
date: "2026-01-26"
topic: "React"
---

We build web apps with React. We build mobile apps with React. We even build 3D apps with React. And yet,
we write the same kind of code everywhere: the same `useState` and `useEffect` hooks, the same function components,
and the same mental model.

Now this raises an interesting question ü§î: how does the same React code run on such different platforms? A web app uses the DOM, a mobile
app uses native views, and a 3D app might use canvas or WebGL. These systems have completely different
ways of drawing UI.

<img src="/react/meme.png" alt="Apple UI example" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

I have been using React for years without even understanding what it really is. I knew about React Native for building mobile apps, and there are tons of other React libraries for different platforms, but I never really tried to understand how people were using React across platforms. My curiosity about how it all works was finally satisfied when I understood what React truly is.

For this blog, I just want to shape the mental model of what React is without diving too deep into React internals.

If you are a little curious about how React runs on different platforms,
then this blog is for you. 

# UI as tree

We all know React is a UI library, but let's step back and think *what exactly *is* UI?*

You might say it's the visual surface we interact with: buttons, links, colors, images, layouts, icons, and more. It consists
of different UI elements.

<img src="/react/apple.png" alt="Apple UI example" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

For the **web**, we use HTML tags like `<div>`, `<button>`, `<a>`, `<img>` to create UI elements

```html
<div class="card">
  <img src="avatar.png" alt="User" />
  <button>Follow</button>
</div>
```

For **mobile apps**, we have native components like `View`, `Pressable`, and `Text`

```tsx
<View style={styles.card}>
  <Image source={avatar} />
  <Pressable onPress={handleFollow}>
    <Text>Follow</Text>
  </Pressable>
</View>
```

When working with UI, we always see the same pattern, whether we are building a mobile app, web app, or anything else: the **hierarchy between UI elements**. 
You have `button` and `img` inside a `div` or `Image` and `Pressable` inside a `View`; they all form a tree-like structure.

<UserCardDemo/>

```zsh
Card
 ‚îú‚îÄ CardContent
 ‚îÇ    ‚îî‚îÄ p
 ‚îî‚îÄ CardFooter
      ‚îú‚îÄ Avatar
      ‚îú‚îÄ UserInfo
      ‚îÇ    ‚îú‚îÄ CardTitle
      ‚îÇ    ‚îî‚îÄ CardDescription
      ‚îî‚îÄ StarIcon
```


React does nothing different it represents your UI in tree as well internally, To understand how this works, let's first understand how React is structured

# React in Two Parts

React can be thought of as **two separate pieces**:

<img src="/react/two parts.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

* **Reconciler** ‚Äì the part that compares UI trees and decides what needs to change (diffing algorithm)
* **Host Instance** ‚Äì the platform-specific renderer (DOM nodes, native views, etc.)

This distinction is crucial for understanding how React works across multiple platforms. React is not just a UI library; it‚Äôs more like a **UI runtime**.

<img src="/react/ui-runtime.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

If you check the [React source code](https://github.com/facebook/react/tree/main/packages), you‚Äôll see two separate packages: `react-reconciler` and `react-dom`.
These two packages are the ones you use to build your web apps.

<img src="/react/react-source-code.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

# react-reconciler

The reconciler handles your props, state, effects, lifecycles, concurrent mode, context, etc. The Reconciler is the brain of React; it performs all
the necessary calculations and gives the output to the renderer

Let's look at an example

<Sandpack
template="react"
files={{
"/App.js": `import { useState } from "react";

export default function CounterApp() {
const [count, setCount] = useState(0);
return ( <div className="container"> <div className="counter"> <h3>Counter App</h3> <Text count={count} /> </div> <div className="buttons">
<button
className="decrement"
onClick={() => setCount(count - 1)}
>
Decrement </button>
<button
onClick={() => setCount(count + 1)}
>
Increment </button> </div> </div>
);
}

function Text({ count }) {
return <span className="count">Count: {count}</span>;
}
`,
    "/styles.css": `.container {
display: flex;
flex-direction: column;
gap: 24px;
padding: 32px;
font-family: system-ui, sans-serif;
max-width: 320px;
margin: 0 auto;
align-items: center;
}

.counter {
display: flex;
flex-direction: column;
align-items: center;
gap: 8px;
}

h3 {
margin: 0;
color: #666;
font-size: 1.125rem;
font-weight: 500;
}

.count {
font-size: 1.5rem;
font-weight: 700;
font-family: monospace;
}

.buttons {
display: flex;
gap: 16px;
}

button {
padding: 8px 16px;
border-radius: 6px;
border: 1px solid #e2e8f0;
background: white;
color: #0f172a;
font-weight: 500;
cursor: pointer;
transition: all 0.2s;
}

button:hover {
background: #f8fafc;
border-color: #cbd5e1;
}

button.decrement {
color: #ef4444;
border-color: #fee2e2;
background: #fef2f2;
}

button.decrement:hover {
background: #fee2e2;
border-color: #fca5a5;
}
`
}}
/>

In this example, we have a `Text` component and a `CounterApp` component. We are passing count into the `Text` component via props.

When you first run this code, the reconciler internally makes a UI tree for itself; it has no idea about the DOM. It just takes your JSX component 
files and builds a UI tree 

For those of you who have some idea of React internals, yes, it's the `fiber` object

<img src="/react/card.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

When state updates happen, React continues to work only with this in-memory UI tree. It does not directly touch the DOM while figuring out what changed.


<img src="/react/clicked.png" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />


When you click the `increment` button, you call the `setCount` function to change the state. What happens here is that 
we request the reconciler to re-render our component. Well, you don't directly request the reconciler through your code; it's just 
how it works internally. All you did was call the `setCount` function, and that's what triggered the re-render


Now, the reconciler will create a new, updated UI tree by re-running your relevant component with the new state value.

<img src="/react/cardnew.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

Once the new UI tree is created, it compares the old UI tree with the new UI tree

<img src="/react/compare.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />


After the comparison, it comes to a conclusion (effects): _we have everything the same; `button`, `h3`, and other components look fine, so we don't need to touch them.
Only the text in the span tag needs an update._ 

The reconciler just produced a list of effects that need to be applied to the DOM, but it doesn't apply them itself. In fact, it doesn't even know what the DOM is; it's just happy with its in-
memory UI tree



# react-dom (Host Renderer)

Now that we have the list of effects (the "what to do"), it's the job of the host renderer to take those effects and apply them.

Every UI element can be created, updated, or removed using **platform-specific imperative APIs**. For example, the DOM uses `appendChild`, while iOS uses `addSubview`.

`react-dom` uses the DOM APIs to work with those effects given by the reconciler. It does the work of updating text, removing elements, or creating elements.
In our example, we simply update the `textNode` in the `span` tag

```js
textNode.nodeValue = "1"
```

The host instance is the actual DOM node (or native view in React Native) that React manages. Depending on the platform, the host instance can be:

* DOM nodes (Web)
* Native views (iOS/Android)
* PDF primitives ([React PDF](https://react-pdf.org))
* Canvas, WebGL, or anything else

# Why this split matters

This separation allows React to reuse the same reconciliation logic across platforms. Think of it like this:

_I know what changed. I know how to update efficiently. I will give you the list of work to be done on the UI; you, host renderer, do the rest._

This is why you can **use the same hooks (`useState`, `useEffect`) and function components everywhere**, whether the platform is DOM, mobile native components, or canvas.


## react-ink

`react-ink` is another React renderer for building terminal apps

```tsx 

import React, {useState, useEffect} from 'react';
import {render, Text} from 'ink';

const Counter = () => {
	const [counter, setCounter] = useState(0);

	useEffect(() => {
		const timer = setInterval(() => {
			setCounter(previousCounter => previousCounter + 1);
		}, 100);

		return () => {
			clearInterval(timer);
		};
	}, []);

	return <Text color="green">{counter} tests passed</Text>;
};

render(<Counter />);

```
<img src="/react/demo.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

You can use the same power of React, which includes `functional components`, `hooks`, `JSX syntax`, etc., but now the output is not DOM nodes, but rather a terminal UI. 

So, the host renderer decides how to draw, and the reconciler provides the optimal answer of what to draw and where to draw ü§Ø


# Why diffing?

Why not just create the new UI from scratch? Because adding elements to the DOM is expensive. Browsers must handle style recalculation, layout (reflow), repaint, and compositing. For complex UIs, creating thousands of elements repeatedly is costly.

<img src="/react/chess.png" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

The diffing algorithm finds **only the minimal part of the UI that needs updating**, avoiding unnecessary operations.


# What if no React?

React is a declarative UI library that automatically syncs state with the rendered UI.

```js
const el = document.createElement("div")
el.textContent = count
document.body.appendChild(el)

button.addEventListener("click", () => {
  count++
  el.textContent = count
})
```

Without React, you‚Äôd manually handle:

* Creating elements
* Updating text
* Wiring updates
* Keeping everything in sync

With React, you simply say:

> ‚ÄúWhen state is `count`, the UI should look like this.‚Äù

React figures out when to re-render, what changed, and how to update the real UI.




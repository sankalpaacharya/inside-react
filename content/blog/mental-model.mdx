---
title: "Running React on different Platforms"
description: "The correct mental model for understanding React across platforms"
date: "2026-02-03"
topic: "React"
---

React has been dominating frontend for years now. It’s everywhere web apps, 
mobile apps, even TVs. But the crazy thing isn’t just where React runs. It’s 
how everything else started building around it. Whole frameworks exist because of React

<img src="/react/meme.png" alt="Apple UI example" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

To be honest I have been using React for years without even understand what it really is, I knew there exist a react-native
for building mobile apps and there exists a tons of other react libraries for building on different platform. But I never
really tried understanding how people are using React on different platforms but my doubt of HOW got clear when i understood
what react truly is. 

if you are little curious to know how react is running on different platform then this blog is for you. 
we build a mental model for what react is and we will unwrap little things here and later we will get glimpse of some core react internal along 
the way



# UI as tree

We all know React is a UI library, but let's step back and think _what exactly *is* UI?_

You might say it's the visual surface we interact with: buttons, links, colors, images, layouts, icons, and more. It consists
of different UI elements.

<img src="/react/apple.png" alt="Apple UI example" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

For the **web**, we use HTML tags like `<div>`, `<button>`, `<a>`, `<img>` to create UI elements

```html
<div class="card">
  <img src="avatar.png" alt="User" />
  <button>Follow</button>
</div>
```

For **mobile apps**, we have native components like `View`, `Pressable`, and `Text`

```tsx
<View style={styles.card}>
  <Image source={avatar} />
  <Pressable onPress={handleFollow}>
    <Text>Follow</Text>
  </Pressable>
</View>
```

When working with UI we always have this one pattern in common either you are building a mobile app, web app or anything

it's the hirecy between the UI elements, you have `button`, `img` inside `div` or `Image` `Pressable` inside `View` they all
form a tree like structure.

 <UserCardDemo/>

```zsh
Card
 ├─ CardContent
 │    └─ p
 └─ CardFooter
      ├─ Avatar
      ├─ UserInfo
      │    ├─ CardTitle
      │    └─ CardDescription
      └─ StarIcon

```
Every UI element can be created, updated, or removed using platform-specific imperative APIs. For example, the DOM uses `appendChild`, while iOS uses `addSubview`.
Each platform exposes its own APIs for managing UI elements.


React do the simple thing, it represents your UI in tree like structure internally and uses the APIs to manage the UI elements.
If there is a state change in the application it will go which part needs to be `created`, `updated`, `deleted` and once it 
figures out, it creates a new UI tree and it will use the APIs to make changes. It is doing nothing much but just keeping your data and UI in sync.




<Sandpack
  template="react"
  files={{
    "/App.js": `import { useState } from "react";

export default function CounterApp() {
  const [count, setCount] = useState(0);
  return (
    <div className="container">
      <div className="counter">
        <h3>Counter App</h3>
        <Text count={count} />
      </div>
      <div className="buttons">
        <button 
          className="decrement"
          onClick={() => setCount(count - 1)}
        >
          Decrement
        </button>
        <button 
          onClick={() => setCount(count + 1)}
        >
          Increment
        </button>
      </div>
    </div>
  );
}

function Text({ count }) {
  return <span className="count">Count: {count}</span>;
}
`,
    "/styles.css": `.container {
  display: flex;
  flex-direction: column;
  gap: 24px;
  padding: 32px;
  font-family: system-ui, sans-serif;
  max-width: 320px;
  margin: 0 auto;
  align-items: center;
}

.counter {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

h3 {
  margin: 0;
  color: #666;
  font-size: 1.125rem;
  font-weight: 500;
}

.count {
  font-size: 1.5rem;
  font-weight: 700;
  font-family: monospace;
}

.buttons {
  display: flex;
  gap: 16px;
}

button {
  padding: 8px 16px;
  border-radius: 6px;
  border: 1px solid #e2e8f0;
  background: white;
  color: #0f172a;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}

button:hover {
  background: #f8fafc;
  border-color: #cbd5e1;
}

button.decrement {
  color: #ef4444;
  border-color: #fee2e2;
  background: #fef2f2;
}

button.decrement:hover {
  background: #fee2e2;
  border-color: #fca5a5;
}
`
  }}
/>

In the above example, if you take a look we have a `Text` component and a `CounterApp` component, we are passing `count` into a `Text` component via _props_

React already has already made a UI tree with itself in memory when initially components where mount, it knows how your UI looks like, where is your `Text` component how many states you have inside that component, how many `props` is passed into that component, it has all information about your UI from tip to tail in a complex 
data structure

When you click the `Increment` buttons inside the `CounterApp` the state is changed, It will be like _ah something has changed, i need to update_, _I already have this 
UI tree_

```bash
Before click (count = 0)

CounterApp
 ├─ h3: "Counter App"
 └─ Text
      └─ span: "Count: 0"
```

_but it's not updated, let me see what to update and I will make new UI tree_, _oh i got it, it's the `Text` Component_. _Good, Now I have this new UI tree with me_

```bash 
After click (count = 1)

CounterApp
 ├─ h3: "Counter App"
 └─ Text
      └─ span: "Count: 1"
```


_but the screen is still the old one_


<img src="/react/oldui.png" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

_now let me use this API and update the screen as well_

```js
textNode.nodeValue = "1"

```

<img src="/react/newui.png" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />


Now this begs a question: are we really creating a completely new UI every time state changes? Not at all. That would be super inefficient.

React is smart. It figures out exactly what needs to change by comparing the new UI tree with the old one. You saw above that we only needed `textNode.nodeValue` to update the value. We did not recreate the whole UI from scratch.

This is where the diffing algorithm comes in. It finds the minimal part of the UI that needs updating so we are not unnecessaryly doing things

> Remember this part clearly, it first finds what needs to be change and then go and make changes on screen.

## What if no React ?
React is a declarative UI library that automatically syncs application state with the rendered UI.

```js 
const el = document.createElement("div")
el.textContent = count
document.body.appendChild(el)

button.addEventListener("click", () => {
  count++
  el.textContent = count
})

```

if you were to use the DOM APIs you were responsible for  
- creating elements
- updating text
- wiring updates
- keeping everything in sync

but with our above counter app we never did that right? we didn't care about creating element, finding element, updating text node, React did that for us


you only say "_When state is `count`, the UI should look like this_". React will figure out when to re-render, 
what changed, how to update the real UI. We will discuss in depth how it does and everything in later 
blog in this series


## Summary

UI on any platform forms a tree like structure. React keeps its own version of this UI tree in memory.

When state changes, React first builds a new tree, compares it with the old one, and figures out what actually changed. Only then does it use platform specific APIs to update the real screen.

This is how React keeps your data and UI in sync, without you manually touching the DOM or native APIs.


# React in Two Parts

Let's divide react into two parts

<img src="/react/two parts.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

-  **Reconciler**  the diffing algorithm
- **Host Instance**  the platform-specific renderer

This distinction is important for us to understand how react is working on multiple platforms, and how react is
just not a UI library but it's a _UI as a runtime_

<img src="/react/ui-runtime.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

If you check the [react source code](https://github.com/facebook/react/tree/main/packages), there is a two seperate packages `react-reconciler` and `react-dom`

<img src="/react/react-source-code.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />


# React Reconciler

Earlier we dicussed how re-creating the whole UI can be inefficient so we only change what is needed, so how will
we decide what is only needed? It's the reconcillation process which helps us do that

React Reconciler is a core React, which does the diffing, all the computation and tells how our UI should look like
now, it doesn't care about Host instance, it just outputs the UI tree and now it's the job of another program 
to take that UI tree and use the platform specific API and display on screen. 

Reconciler is taking your UI and building a complex UI tree and when there is a state update it will generate 
a new updated UI tree and checks between them

<ReconcileDemo />

# Host Instance (react-dom)

Host instance is the underlying DOM node (or native view in React Native) that React manages. 

What we saw earlier
is react has this internal UI tree with itself in memory and once it creates a new UI tree it compares it with the 
old one and make changes, so in order to make changes in the screen it has to use the platform specific API

Host instance can be anything, either DOM nodes or [native view]() or [PDF primitives](https://react-pdf.com) it can be anything depending  on the platform we are.


It's like we have two puzzle pieces, 

<img src="/react/host.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />



<img src="/react/connected.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

